{
  "hash": "1e4b9b37e4774692ec610a391490f60f",
  "result": {
    "markdown": "---\ntitle: \"Recodage multiple\"\n\n# subtitle: \"\"\n\ncategories:\n  - Boucle\n  - Recodage\n  \nauthor: \n  - name: \"Arno Muller\"\n    affiliations:\n      - name: \"Ined\"\n\ndate: 06/28/2023\n\nimage: \"https://www.r-project.org/Rlogo.png\"\n\nformat: \n  html: default\n  docx: default\n#  pdf:  default\n\nfilters:\n  - lightbox\nlightbox: auto\n\ncode-annotations: below\n\nabstract: | \n Lors du nettoyage des données, on peut être amené à appliquer le même recodage à plusieurs variables aux modalités similaire (valeurs manquantes, Ne sait pas, Batterie de variables semblables, ... ). Pour éviter de copier-coller un même code, on peut facilement automatiser le processus sur R. \n---\n\n\n\n| Packages      | Fonctions                                                       |\n|---------------|-----------------------------------------------------------------|\n| **dplyr**     | `mutate_all` - `mutate_if` - `mutate_at` - `ifelse` - `select`  |\n| **Base R**    | `as.data.frame` - `for` - `grep` - `assign` - `get` - `paste`   |\n\n: **Fonctions utilisées dans la fiche**\n\n\nIl existe plusieurs solutions pour automatiser un recodage dans R, nous allons aborder certaines d'entre-elles mais cette liste est loin d'être exhaustive.\n\n\n# Données d'exemple\n\nOn commence par créer un jeu de données, composé de 10 lignes et 10 colonnes, et qui contient des valeurs manquantes:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\ndf <- as.data.frame(matrix(sample(c(NA, 1:10), 100, replace = TRUE), 10))\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   V1 V2 V3 V4 V5 V6 V7 V8 V9 V10\n1   8 NA  8  5  8  5  5  8  6   1\n2   3  4  8  9  7  7  6  6  6   9\n3   6  4  4  9  8  1  5  3  2  NA\n4  NA  9  4  5  6  1  7  6  5  10\n5   1  5  1  3  7  5  6  5  1  10\n6   6  9  9  3  5  5 10 NA  9   9\n7  10  6  8  9  9 NA NA  4 10   9\n8   1  8 NA  8  6  2  3  5  9   7\n9  10  4  3  6  2  2  7 NA  6   9\n10  2  4  2  5  9  7  8  8  2   4\n```\n:::\n:::\n\n\n\n\n# Avec R de base :\n\nDans le R de base, il est possible de recoder l'entiereté des occurences d'une certaines valeurs (ou les valeurs manquantes) pour l'ensemble du jeu de données.\n\n## Sur l'ensemble des données\n\n### Exemple 1 : Changer l'ensemble des valeurs manquantes\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Je fais un copie du jeu de donnée\ndf2 <- df\n# Je remplace tous les NA par la valeurs 0\ndf2[is.na(df2)] <- 0\ndf2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   V1 V2 V3 V4 V5 V6 V7 V8 V9 V10\n1   8  0  8  5  8  5  5  8  6   1\n2   3  4  8  9  7  7  6  6  6   9\n3   6  4  4  9  8  1  5  3  2   0\n4   0  9  4  5  6  1  7  6  5  10\n5   1  5  1  3  7  5  6  5  1  10\n6   6  9  9  3  5  5 10  0  9   9\n7  10  6  8  9  9  0  0  4 10   9\n8   1  8  0  8  6  2  3  5  9   7\n9  10  4  3  6  2  2  7  0  6   9\n10  2  4  2  5  9  7  8  8  2   4\n```\n:::\n:::\n\n\n\n### Exemple 2 : Remplacer une valeur par une autre\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Je fais une copie de l'original\ndf2 <- df\n# Je remplace tous les 10 par la valeur \"DIX\"\ndf2[df2==10] <- \"DIX\"\ndf2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     V1 V2 V3 V4 V5 V6   V7 V8  V9  V10\n1     8 NA  8  5  8  5    5  8   6    1\n2     3  4  8  9  7  7    6  6   6    9\n3     6  4  4  9  8  1    5  3   2 <NA>\n4  <NA>  9  4  5  6  1    7  6   5  DIX\n5     1  5  1  3  7  5    6  5   1  DIX\n6     6  9  9  3  5  5  DIX NA   9    9\n7   DIX  6  8  9  9 NA <NA>  4 DIX    9\n8     1  8 NA  8  6  2    3  5   9    7\n9   DIX  4  3  6  2  2    7 NA   6    9\n10    2  4  2  5  9  7    8  8   2    4\n```\n:::\n:::\n\n\n\n\n\n## Sur une sélection de variables\n\nLes jeux de données peuvent être composés d'un grand nombre de variables et donc on peut-être amené à effectuer un recodage uniquement sur certaines variables.\n\nL'exemple ci-dessous montre comment procéder à partir d'une sélection de variable stockée dans le vecteur *var*.\n\n### Exemple 3 : Recoder une sélection de variables\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Je fais une copie de l'original\ndf2 <- df\n# Je choisis certaines variables sur lesquelle on appliquera le recodage\nvar <- c(\"V1\",\"V7\",\"V9\")\n\n# Fonctionne aussi avec la position de la colonne\n# var <- c(2,5,6)\n\n# On crée une boucle qui s'activera uniquement pour les variables contenues \n# dans var\n\nfor (i in var) {\n  df2[[i]] <- ifelse(df2[[i]] == 10, \"DIX\", df2[[i]])\n}\n\n\ndf2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     V1 V2 V3 V4 V5 V6   V7 V8  V9 V10\n1     8 NA  8  5  8  5    5  8   6   1\n2     3  4  8  9  7  7    6  6   6   9\n3     6  4  4  9  8  1    5  3   2  NA\n4  <NA>  9  4  5  6  1    7  6   5  10\n5     1  5  1  3  7  5    6  5   1  10\n6     6  9  9  3  5  5  DIX NA   9   9\n7   DIX  6  8  9  9 NA <NA>  4 DIX   9\n8     1  8 NA  8  6  2    3  5   9   7\n9   DIX  4  3  6  2  2    7 NA   6   9\n10    2  4  2  5  9  7    8  8   2   4\n```\n:::\n:::\n\n\n\n\nSeulement les variables V1, V7 et V9 ont été recodées. On remarque que des valeurs 10 sont présentes dans la variable V10.\n\n\n# Avec le package `dplyr`du tidyverse :\n\nLes boucles peuvent être complexe à prendre en main, et pas forcément conseillées dans R. Le package `dplyr` propose un ensemble de fonctions permettant de recoder plusieurs variables avec seule une fonction.\n\n\n## Sur l'ensemble des données\n\nLa fonction `mutate_all` permet de recoder l'ensemble des variables du jeu de données.\n\n### Exemple 4 : **`mutate_all`**\n\nOn remplace l'ensemble de 7 par la valeur \"SEPT\"\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\ndf2 <- df %>% \n  mutate_all(~ifelse(. == 7, \"SEPT\", .))\ndf2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   V1 V2 V3 V4   V5   V6   V7 V8 V9  V10\n1   8 NA  8  5    8    5    5  8  6    1\n2   3  4  8  9 SEPT SEPT    6  6  6    9\n3   6  4  4  9    8    1    5  3  2 <NA>\n4  NA  9  4  5    6    1 SEPT  6  5   10\n5   1  5  1  3 SEPT    5    6  5  1   10\n6   6  9  9  3    5    5   10 NA  9    9\n7  10  6  8  9    9 <NA> <NA>  4 10    9\n8   1  8 NA  8    6    2    3  5  9 SEPT\n9  10  4  3  6    2    2 SEPT NA  6    9\n10  2  4  2  5    9 SEPT    8  8  2    4\n```\n:::\n:::\n\n\n\n- Le signe **`~`** est obligatoire, et permet d'indiquer qu'on applique la formule qui le suit à l'ensemble du jeu de données.  \n\n- Les **`.`** sont une spécificité de la syntaxe sous forme de **pipes** (%>%). Ils sont synonymes de la base de données en entrée (df) mais permet de tenir compte de toutes les transformations des pipes précédentes faites sur cette base.\n\n\n\n## Sur une sélection de variables\n\nLes fonctions `mutate_if` et `mutate_at` permettent d'appliquer un recodage mais uniquement sur des variables choisies par une ou plusieurs conditions.\n\n### Exemple 5 : `mutate_if`\n\nDans cet exemple, on va appliquer un recodage uniquement aux variables numériques.\nPour l'exemple, on commence par créer une variable catégorielle *var_categ*, sur laquelle le recodage ne s'appliquera pas.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf2 <- df %>% \n  mutate(var_categ = rep(c(\"bonjour\", \"5\"), 5)) %>% \n  select(var_categ, everything())\ndf2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   var_categ V1 V2 V3 V4 V5 V6 V7 V8 V9 V10\n1    bonjour  8 NA  8  5  8  5  5  8  6   1\n2          5  3  4  8  9  7  7  6  6  6   9\n3    bonjour  6  4  4  9  8  1  5  3  2  NA\n4          5 NA  9  4  5  6  1  7  6  5  10\n5    bonjour  1  5  1  3  7  5  6  5  1  10\n6          5  6  9  9  3  5  5 10 NA  9   9\n7    bonjour 10  6  8  9  9 NA NA  4 10   9\n8          5  1  8 NA  8  6  2  3  5  9   7\n9    bonjour 10  4  3  6  2  2  7 NA  6   9\n10         5  2  4  2  5  9  7  8  8  2   4\n```\n:::\n:::\n\n\n\nOn utilise **`mutate_if`**, pour changer la valeur 5 en CINQ, uniquement pour les variables numériques.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf2 <- df2 %>% \n  mutate_if(is.numeric, ~ifelse(. == 5, \"CINQ\", .))\ndf2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   var_categ V1   V2 V3   V4   V5   V6   V7   V8   V9 V10\n1    bonjour  8 <NA>  8 CINQ    8 CINQ CINQ    8    6   1\n2          5  3    4  8    9    7    7    6    6    6   9\n3    bonjour  6    4  4    9    8    1 CINQ    3    2  NA\n4          5 NA    9  4 CINQ    6    1    7    6 CINQ  10\n5    bonjour  1 CINQ  1    3    7 CINQ    6 CINQ    1  10\n6          5  6    9  9    3 CINQ CINQ   10 <NA>    9   9\n7    bonjour 10    6  8    9    9 <NA> <NA>    4   10   9\n8          5  1    8 NA    8    6    2    3 CINQ    9   7\n9    bonjour 10    4  3    6    2    2    7 <NA>    6   9\n10         5  2    4  2 CINQ    9    7    8    8    2   4\n```\n:::\n:::\n\n\n\n### Exemple 6 : **`mutate_at`**\n\nla fonction `mutate_at` permet d'appliquer un recodage à un ensemble de variables définies par leur nom. \n\nIci, on applique le recodage uniquement aux variables qui continennent la chaîne de caractéres V1 dans leur nom de variables, on recode donc V1 et V10.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sélection des variables\nvar <- grep(\"1\", names(df), value=TRUE)\nvar\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"V1\"  \"V10\"\n```\n:::\n\n```{.r .cell-code}\n# On recode les NA en VAL.MANQ pour les variables de var\ndf2 <- df %>% \n  mutate_at(var, ~ ifelse(is.na(.) == TRUE, \"VAL.MANQ\", .))\ndf2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         V1 V2 V3 V4 V5 V6 V7 V8 V9      V10\n1         8 NA  8  5  8  5  5  8  6        1\n2         3  4  8  9  7  7  6  6  6        9\n3         6  4  4  9  8  1  5  3  2 VAL.MANQ\n4  VAL.MANQ  9  4  5  6  1  7  6  5       10\n5         1  5  1  3  7  5  6  5  1       10\n6         6  9  9  3  5  5 10 NA  9        9\n7        10  6  8  9  9 NA NA  4 10        9\n8         1  8 NA  8  6  2  3  5  9        7\n9        10  4  3  6  2  2  7 NA  6        9\n10        2  4  2  5  9  7  8  8  2        4\n```\n:::\n:::\n\n\n\n\n\n\n# Automatisation de la création de nouvelles variables\n\nJusqu'ici nous avons vu comment recoder des variables existantes en changeant leurs valeurs, mais il est souvent préférable de créer de nouvelles variables pour éviter de perdre la variable originale.\n\n\n### Exemple 7 : Avec une boucle **`for`** et **`assign`**\n\nDans cet exemple, nous allons choisir 3 variables à recoder (\"V1\",\"V3\",\"V5\"), mais au lieu de les écraser avec leurs nouvelles valeurs nous allons créer des copies de ces variables qui porteront le suffixe *bis*.\n\nSi l'opération peut sembler facile aux premier abord, créer des nouveaux objets et leur affecter automatiquement une nouvelle valeur pose un problème majeur dans R : **Il n'est pas possible d'écrire une fonction devant un symbole d'affectation comme le = ou le <- **\n\nCela signifie que pour créer de nouvelles variables, on ne peut pas écrire :  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# IMPOSSIBLE\npaste0(V1, \"_bis\") <- ifelse(df$V1 == 8, \"HUIT\", df$V1)\n# IMPOSSIBLE\ndf$paste0(V1, \"_bis\")\n```\n:::\n\n\n\n\n\nPour contourner ce problème, on utilise la fonction **`assign()`**, qui contient deux arguments : `assign(NOM_NV_OBJ, valeurs_prisent)`. On peut donc créer des variables avec des noms issues de fonctions comme `paste`. Dans notre cas on colle *ANCIEN_NOM* et *bis*.\n\n\nPour chercher cet objet stocké dans l'environnement et en faire une variable, on utilise la fonction `get()` qui permet d'utiliser des fonctions comme `paste()` pour récupérer les valeurs des objets crées automatiquement.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Copie de l'original\ndf2 <- df\n# Sélecion des variables\nvar <- c(\"V1\",\"V3\",\"V5\")\n\nfor (i in var) {\n  \n  assign(paste0(i,\"_bis\"),                       # Nom de l'objet\n         ifelse(df2[[i]] == 8, \"HUIT\", df2[[i]]) # Valeur qu'il prend\n         )\n  \n  # On crée la variable à partir de l'objet crée au dessus\n  df2[paste0(i,\"_bis\")] <- get(paste0(i,\"_bis\"))\n\n}\n\n\n# On affiche la base avec les nouvelles variables en premières\ndf2 %>% \n  select(contains(\"bis\"), everything())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   V1_bis V3_bis V5_bis V1 V2 V3 V4 V5 V6 V7 V8 V9 V10\n1    HUIT   HUIT   HUIT  8 NA  8  5  8  5  5  8  6   1\n2       3   HUIT      7  3  4  8  9  7  7  6  6  6   9\n3       6      4   HUIT  6  4  4  9  8  1  5  3  2  NA\n4    <NA>      4      6 NA  9  4  5  6  1  7  6  5  10\n5       1      1      7  1  5  1  3  7  5  6  5  1  10\n6       6      9      5  6  9  9  3  5  5 10 NA  9   9\n7      10   HUIT      9 10  6  8  9  9 NA NA  4 10   9\n8       1   <NA>      6  1  8 NA  8  6  2  3  5  9   7\n9      10      3      2 10  4  3  6  2  2  7 NA  6   9\n10      2      2      9  2  4  2  5  9  7  8  8  2   4\n```\n:::\n:::\n\n\n\n\nOn a bien crée automatiquement de nouvelles variables, tout en conservant les anciennes.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "supporting": [
      "recodage_multiple_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}