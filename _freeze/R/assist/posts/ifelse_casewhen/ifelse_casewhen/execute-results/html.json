{
  "hash": "24fbe0d3b71a6a40e2d4392984b1514d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Recoder des variables avec ifelse() - if_else - case_when()\"\n\ncategories:\n  - Recodage\n  \nauthor: \n  - name: \"Arno Muller\"\n    affiliations:\n      - name: \"Ined\"\n\ndate: 06/27/2023\n\nimage: \"https://www.r-project.org/Rlogo.png\"\n\nformat: \n  html: default\n  docx: default\n\nfilters:\n  - lightbox\nlightbox: auto\n\ncode-annotations: below\n\nabstract: | \n Lors d'un recodage d'une variable, on peut être emmené à créer des catégories dépendantes d'une ou plusieurs conditions. Pour cela, la plus part des logiciels permettent des fonctions qui suivent le schéma : SI condition ALORS catégorie1 SINON catégorie2. \n Sur R, plusieurs possibilités s'offrent à l'utilisateur.rice : notamment `ifelse()`, `if_else()`, `case_when()`.\n---\n\n\n| Packages      | Fonctions                                       |\n|---------------|-------------------------------------------------|\n| **dplyr**     | `if_else` - `case_when` - `mutate`              |\n| **Base R**    | `ifelse` `table`                                |\n\n: **Fonctions utilisées dans la fiche**\n\n\n![](img/Schema_ifelse_base.png){width=\"50%\"}\n\n# R base : `ifelse()`\n\n## Pro/Cons :\n\n*Avantage :*\\\n- Pas besoin de packages supplémentaires\n\n*Inconvénient :*\n\n-   Lent\n\n-   Problème de persistence des types de modalités (surtout avec les labels et les factors)[^1]\n\n[^1]: <https://community.rstudio.com/t/case-when-why-not/2685/3>\n\n-   Code moins lisible\n-   Gestion des conditions multiples illisibles\n\n## Exemple 1 : Variables dichotomiques\n\nCréation d'une variable catégorielle *taille_rec*, avec deux modalités : \"Grand.e\", \"Petit.e\".\n\n![](img/Schema_ifelse_ex1.png){width=\"33%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sélection d'une seed pour obtenir le même échantillon \n# dans la création des données fictive aléatoires\nset.seed(1)\n\n# Création du jeu de données exemple\nindividus <- data.frame(\n  id = 1:20,\n  # Âges aléatoires entre 18 et 65 ans\n  age = sample(18:65, 20, replace = TRUE), \n  # Tailles aléatoires entre 150 et 200 cm\n  taille = sample(150:200, 20, replace = TRUE), \n  # Sexe aléatoire (Homme ou Femme)\n  sexe = sample(c(\"Homme\", \"Femme\"), 20, replace = TRUE) \n)\n\n\n# Ajout d'une variable taill_rec pour illustrer l'utilisation de ifelse()\nindividus$taille_rec <- ifelse(individus$taille > 175, # Condition \n                               \"Grand.e\",              # Catégorie si VRAI \n                               \"Petit.e\")              # Catégorie si FAUX\n\n\n# Affichage de la nouvelle variable\ntable(individus$taille_rec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nGrand.e Petit.e \n     12       8 \n```\n\n\n:::\n:::\n\n\n## Exemple 2 : Variables avec plus de 2 modalités\n\nIl est possible d'empiler les fonctions `ifelse()` pour créer des variables avec plus de deux modalités. Pour cela on suit le schéma suivant :\n\n![](img/Schema_ifelse_ex2.png){width=\"50%\"}\n\nDans cet exemple, on divise la taille en 3 catégories :\n\n-   Petit.e : < 165  \n-   Moyen.ne : De 165 à 185  \n-   Grand.e : > 185\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindividus$taille_rec2 <- ifelse(individus$taille > 185,      # Condition 1\n                               \"Grand.e\",                    # Condi 1 Vrai \n                               ifelse(individus$taille < 165,# Condition 2\n                                      \"Petit.e\",             # Condi 2 Vrai\n                                      \"Moyen.ne\"))           # Condi 1&2 Fausse\n                               \n\n\n# Affichage de la nouvelle variable\ntable(individus$taille_rec2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n Grand.e Moyen.ne  Petit.e \n       8        9        3 \n```\n\n\n:::\n:::\n\n\n## Exemple 3 : Conditions issues de deux variables initiales\n\nIl est également possible de créer des variables à partir de conditions provenant de plusieurs variables.\n\nDans cet exemple, nous allons créer une variable dont les catégories seront différentes selon pour les hommes et les femmes :\n\n<br>\n\n::: columns\n::: {.column width=\"40%\"}\n*Pour les hommes :*\n\n-   Petit.e : < 180  \n-   Grand.e : >= 180  \n\n*Pour les femmes :*\n\n-   Petit.e : < 170  \n-   Grand.e : >= 170  \n:::\n\n::: {.column width=\"60%\"}\n![](img/Schema_ifelse_ex3.png){width=\"75%\"}\n:::\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindividus$taille_rec3 <- ifelse(individus$sexe == \"Homme\" & \n                                  individus$taille < 180,      # Condition 1\n                                # Condition 1 Vraie :\n                                \"Petit.e\",    \n                                # Sinon :\n                                ifelse(individus$sexe == \"Femme\" & \n                                  individus$taille < 170,      # Condition 2\n                                  # Condition 2 Vraie :\n                                  \"Petit.e\",  \n                                  # Tous les autres :\n                                  \"Grand.e\"))          \n                               \n\n\n# Affichage de la nouvelle variable\ntable(individus$taille_rec3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nGrand.e Petit.e \n     14       6 \n```\n\n\n:::\n:::\n\n\n# Dplyr : `if_else()`\n\n## Pro/Cons :\n\n*Avantage :*\n\nLe package *dplyr*, présent dans le *tidyverse*, propose sa propre version de la fonction `ifelse()`, qui permet d'éviter certains problèmes rencontrer avec la version de base.\n\nAinsi, `if_else()` s'utilise exactement de la même manière que `ifelse`, elle est plus rapide et permet de conserver le type de la variable initiale.\n\n*Inconvénient :*\n\n-   Besoin d'installer un package\n-   Gestion des conditions multiples toujours illisibles\n\n## Exemple 4 : `if_else()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#install.packages(\"dplyr\")\nlibrary(dplyr)\n\nindividus$taille_rec4 <- if_else(individus$sexe == \"Homme\" & \n                                  individus$taille < 180,      # Condition 1\n                                # Condition 1 Vraie :\n                                \"Petit.e\",    \n                                # Sinon :\n                                if_else(individus$sexe == \"Femme\" & \n                                  individus$taille < 170,      # Condition 2\n                                  # Condition 2 Vraie :\n                                  \"Petit.e\",  \n                                  # Tous les autres :\n                                  \"Grand.e\"))          \n                               \n\n\n# Affichage de la nouvelle variable\ntable(individus$taille_rec4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nGrand.e Petit.e \n     14       6 \n```\n\n\n:::\n:::\n\n\n**On obtient bien le même résultat**\n\n# Dplyr : `case_when()`\n\n## Pro/Cons :\n\nLa gestion des conditions multiples pouvant être fastidieuse avec les fonctions `ifelse()`, le code devenant rapidemment illisible, *dplyr* propose la fonction `case_when()` qui permet de l'organiser mieux.\n\nSon fonctionnement se base sur des formules, il peut alors sembler plus ou moins compréhensibles selon les sensibilités de programmations.\n\n# Exemple 5 : Variable dichotomique\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nindividus$taille_rec5 <- case_when(\n  individus$taille > 175 ~ \"Grand\", # Condition 1 ~ Resultat 1\n  individus$taille <= 175 ~ \"Petit\" # Condition 2 ~ Resultat 2\n)\n\n# Exemple avec catégorie \"ELSE\"\nindividus$taille_rec5bis <- case_when(\n  individus$taille > 175 ~ \"Grand\", # Condition  ~ Resultat \n  TRUE ~ \"Petit\"                    # Sinon ~ Resultat pour les autres cas\n)\n\n\ntable(individus$taille_rec5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nGrand Petit \n   12     8 \n```\n\n\n:::\n\n```{.r .cell-code}\ntable(individus$taille_rec5bis)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nGrand Petit \n   12     8 \n```\n\n\n:::\n:::\n\n\n# Exemple 6 : Variable avec plusieurs modalités\n\nOn reprend l'exemple 3 avec `case_when()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nindividus$taille_rec6 <- case_when(\n  individus$sexe == \"Homme\" & individus$taille < 180 ~ \"Petit.e\",\n  individus$sexe == \"Femme\" & individus$taille < 170 ~ \"Petit.e\",\n  TRUE ~ \"Grand.e\"\n)\n\ntable(individus$taille_rec6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nGrand.e Petit.e \n     14       6 \n```\n\n\n:::\n:::\n\n\n# Attention !\n\n## Ordre d'affectation des valeurs\n\nAvec `ifelse()` ou avec `case_when`, une fois la première condition remplie, la nouvelle valeur ne peux plus être modifiée, ainsi si une condition future se superpose, elle ne sera pas prise en compte dans le recodage. **On va du plus spécifique au plus général**\n\n*Exemple :*\nOn crée une variable taille avec comme modalité :\n\n-   Petit : < 170  \n-   Moyen : 170 à 185  \n-   Grand : > 185  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nindividus <- individus %>%\n  select(id, taille) %>% \n  \n  mutate(\n    # avec ifelse\n    var1 = ifelse(taille > 170, \"Moyen\", \n                  ifelse(taille > 185, \"Grand\", \"Petit\")),\n    \n    # avec if_else\n    var2 = if_else(taille > 170, \"Moyen\", \n                   if_else(taille > 185, \"Grand\", \"Petit\")),\n    \n    # avec case_when\n    var3 = case_when(\n      taille > 170 ~ \"Moyen\",\n      taille > 185 ~ \"Grand\", \n      TRUE ~ \"Petit\")) \n\ntable(individus$var1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nMoyen Petit \n   14     6 \n```\n\n\n:::\n\n```{.r .cell-code}\ntable(individus$var2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nMoyen Petit \n   14     6 \n```\n\n\n:::\n\n```{.r .cell-code}\ntable(individus$var3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nMoyen Petit \n   14     6 \n```\n\n\n:::\n:::\n\n\nOn voit qu'il n'y a pas la catégorie \"Grand\", comme la valeur a déjà été affectée à la catégorie \"Moyen\". Il faudrait alors :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindividus <- individus %>%\n  mutate(var5 = case_when(\n    taille > 185 ~ \"Grand\", \n    taille > 170 ~ \"Moyen\",\n    TRUE ~ \"Petit\")) \n\ntable(individus$var5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nGrand Moyen Petit \n    8     6     6 \n```\n\n\n:::\n:::\n\n\n## A propos des valeurs manquantes\n\nLes fonctions `ifelse()` n'ont pas le même comportement pour le traitement des valeurs manquantes que la fonction `case_when`.\n\nDans le cas des fonctions `ifelse`, si l'une des variables de conditions est un NA, le résultat sera également une valeur manquante dans la variable crée.\n\nDans le cas de la fonction `case_when`, l'individu avec une valeur manquante aura comme nouvelle valeur la catégorie défini dans la partie \"SINON\".[^2]\n\n[^2]: <https://stackoverflow.com/questions/57807976/how-to-use-case-when-rather-then-if-else-error-in-my-code>\n\n*Exemple :*\n\nOn crée un data frame avec des NA :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\ndf <- data.frame(a = c(1:3, NA, 4,NA,6:7), b = c(NA, letters[1:7]))\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   a    b\n1  1 <NA>\n2  2    a\n3  3    b\n4 NA    c\n5  4    d\n6 NA    e\n7  6    f\n8  7    g\n```\n\n\n:::\n:::\n\n\nOn fait un recodage avec `ifelse()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  mutate(res = if_else(a > 3, \"Yes\", \n                   if_else(b == \"c\", \"No\", \n                           if_else(a > 5, \"Maybe\", \"Done\"))))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   a    b  res\n1  1 <NA> <NA>\n2  2    a Done\n3  3    b Done\n4 NA    c <NA>\n5  4    d  Yes\n6 NA    e <NA>\n7  6    f  Yes\n8  7    g  Yes\n```\n\n\n:::\n:::\n\n\nLes NA restent des NAs, alors qu'avec `case_when` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n   mutate(res = case_when(a > 3 ~ \"Yes\", \n                          b == \"c\"~\"No\", \n                          a > 5 ~ \"Maybe\", \n                          TRUE ~ \"Done\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   a    b  res\n1  1 <NA> Done\n2  2    a Done\n3  3    b Done\n4 NA    c   No\n5  4    d  Yes\n6 NA    e Done\n7  6    f  Yes\n8  7    g  Yes\n```\n\n\n:::\n:::\n\n\nOn a pas de NA, ils ont été recodé avec la catégorie SINON.\n\n**Il faut donc créer une condition avec `is.na(variable)`**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n   mutate(res = case_when(a > 3 ~ \"Yes\", \n                          b == \"c\"~\"No\", \n                          a > 5 ~ \"Maybe\", \n                          is.na(a) | is.na(b) ~ NA,\n                          TRUE ~ \"Done\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   a    b  res\n1  1 <NA> <NA>\n2  2    a Done\n3  3    b Done\n4 NA    c   No\n5  4    d  Yes\n6 NA    e <NA>\n7  6    f  Yes\n8  7    g  Yes\n```\n\n\n:::\n:::\n",
    "supporting": [
      "ifelse_casewhen_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}