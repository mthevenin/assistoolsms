[
  {
    "objectID": "fiches30-06.html",
    "href": "fiches30-06.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "fiches30-06.html#tableau-des-fonctions-utilisées-dans-la-fiche",
    "href": "fiches30-06.html#tableau-des-fonctions-utilisées-dans-la-fiche",
    "title": "",
    "section": "Tableau des fonctions utilisées dans la fiche",
    "text": "Tableau des fonctions utilisées dans la fiche\nExemple de tableau des fonctions pour la fiche d’Elodie (on peut aller en mode visual sur un qmd vierge si on préfère). Le titre est en dessous du tableau=&gt; : **Fonctions utilisées dans la fiche**\n\nFonctions utilisées dans la fiche\n\n\nPackages\nFonctions\n\n\n\n\nquestionr\nwtd.table - cprop - lprop\n\n\nsurvey\nsvydesign - svytable - svymean - svyglm\n\n\nBase R\nmean"
  },
  {
    "objectID": "fiches30-06.html#extensions",
    "href": "fiches30-06.html#extensions",
    "title": "",
    "section": "Extensions",
    "text": "Extensions\nL’extension lightbox est très bien pour l’insersion d’image/graphique. En local pour l’activer, elle doit être installée (si une fiche dans un répertoire, l’installer à chaque fois): dans le terminal =&gt; quarto add quarto-ext/lightbox. Si vous utilisez une autre extension, me l’indiquer que je l’installe dans le répertoire du support."
  },
  {
    "objectID": "fiches30-06.html#lien-documentation",
    "href": "fiches30-06.html#lien-documentation",
    "title": "",
    "section": "Lien documentation",
    "text": "Lien documentation\nDe préférence, je préfèrerais qu’elle soit en début de document, sous le tableau des fonctions."
  },
  {
    "objectID": "R/assist/posts/function_table_auto/fonction_table_auto.html",
    "href": "R/assist/posts/function_table_auto/fonction_table_auto.html",
    "title": "Fonction pour des tables automatiques",
    "section": "",
    "text": "Il existe un large éventail de package R consacré à la gestion et la mise en forme de table et de tris croisés (GT, flextable, …). S’ils sont souvent de grandes qualités, leur coût d’entrée peut être un peu élevé pour les utilisateurs.rices occasionnelles de R.\nPour répondre aux besoins de ces derniers, vous trouverez ici une fonction qui permet de facilement compiler des tris à plats ou bivariées, pour explorer automatiquement un grand nombre de variables, utiliser une pondération et les exporter dans un document Excel.\nPour une introduction aux tables et à la pondération, voir la fiche\n\n\nPour illustrer la mise en oeuvre de la fonction, on utilise les données d’exemples hdv2003 du packages questionr. Ces données possèdent à la fois des variables sur des carastéristiques socio-démographiques, des pratiques et des goûts, et propose une variable de pondération : poids.\n\n\n\nImport des données d'exemples\n\nlibrary(questionr)\ndata(\"hdv2003\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nObtenir une table automatique avec les tris à plat d’un grand nombre de variables\nCroiser ces variables avec une variable choisie, par exemple le sexe ou la qualification et obtenir :\n\nLes effectifs\nLes pourcentages lignes\nLes poucentages colonnes\nAjout d’un test du chi²\n\nUtiliser des pondérations\nGarder ou non les valeurs manquantes\nExporter le tableau obtenu (Par exemple : image ci-dessous)"
  },
  {
    "objectID": "R/assist/posts/function_table_auto/fonction_table_auto.html#données-dexemples",
    "href": "R/assist/posts/function_table_auto/fonction_table_auto.html#données-dexemples",
    "title": "Fonction pour des tables automatiques",
    "section": "",
    "text": "Pour illustrer la mise en oeuvre de la fonction, on utilise les données d’exemples hdv2003 du packages questionr. Ces données possèdent à la fois des variables sur des carastéristiques socio-démographiques, des pratiques et des goûts, et propose une variable de pondération : poids.\n\n\n\nImport des données d'exemples\n\nlibrary(questionr)\ndata(\"hdv2003\")"
  },
  {
    "objectID": "R/assist/posts/function_table_auto/fonction_table_auto.html#objectifs",
    "href": "R/assist/posts/function_table_auto/fonction_table_auto.html#objectifs",
    "title": "Fonction pour des tables automatiques",
    "section": "",
    "text": "Obtenir une table automatique avec les tris à plat d’un grand nombre de variables\nCroiser ces variables avec une variable choisie, par exemple le sexe ou la qualification et obtenir :\n\nLes effectifs\nLes pourcentages lignes\nLes poucentages colonnes\nAjout d’un test du chi²\n\nUtiliser des pondérations\nGarder ou non les valeurs manquantes\nExporter le tableau obtenu (Par exemple : image ci-dessous)"
  },
  {
    "objectID": "R/assist/posts/function_table_auto/fonction_table_auto.html#fonctionnement",
    "href": "R/assist/posts/function_table_auto/fonction_table_auto.html#fonctionnement",
    "title": "Fonction pour des tables automatiques",
    "section": "Fonctionnement",
    "text": "Fonctionnement\nOn utilise la fonction table_auto() qui ne fait partie d’aucun package, il faut donc la charger dans un premier temps dans R. Une fois la fonction chargée, il suffira de la lancer en renseignant les variables, et les options voulues (présence de valeurs manquantes, pondérations, exportation)"
  },
  {
    "objectID": "R/assist/posts/function_table_auto/fonction_table_auto.html#paramètre-de-la-fonction",
    "href": "R/assist/posts/function_table_auto/fonction_table_auto.html#paramètre-de-la-fonction",
    "title": "Fonction pour des tables automatiques",
    "section": "Paramètre de la fonction",
    "text": "Paramètre de la fonction\n\n\n\n\n\n\n\nParamètre\nArgument\n\n\n\n\ndonnees\nUne base de données\n\n\nvars\nUn vecteur avec les différentes variables en lignes\n\n\nvar_crois\n\nSi vide : Tris à plat\nSi une variable : Tris croisés\n\n\n\ntable_type\n\nEffectifs : “eff”\nPourcentage ligne : “pct_ligne”\nPourcentage colonne : “pct_col”\n\n\n\nponder\nUne variable de pondération dans donnee\n\n\nval.manq\n“oui” ou “non”, garder ou non les valeurs manquantes\n\n\narrondi\nNombre de chiffre après la virgule\n\n\nsautdeligne\n“oui” ou “non”, insérer une ligne vide entre chaque variable\n\n\nexport_XLS\n“oui” ou “non”, si oui : création d’un fichier excel."
  },
  {
    "objectID": "R/assist/posts/function_table_auto/fonction_table_auto.html#import-de-la-fonction",
    "href": "R/assist/posts/function_table_auto/fonction_table_auto.html#import-de-la-fonction",
    "title": "Fonction pour des tables automatiques",
    "section": "Import de la fonction",
    "text": "Import de la fonction\nLancer le code suivant, pour enregistrer la fonction dans l’environnement global :\n\n\n\nImport de la fonction\n\ntable_auto &lt;- function(donnees, \n                       vars, \n                       var_crois   = NULL, \n                       table_type  = \"eff\",\n                       ponder      = NULL, \n                       val.manq    = \"oui\",\n                       arrondi     = 2, \n                       sautdeligne = \"oui\",\n                       export_XLS  = \"non\"){\n  \n  ### GESTION LIBRARY ----\n  \n  # Liste des packages à charger\n  packages &lt;- c(\"tidyverse\", \"questionr\", \"openxlsx\")\n  \n  # Vérifier si les packages sont déjà installés\n  missing_packages &lt;- packages[!(packages %in% installed.packages()[,\"Package\"])]\n  \n  # Installer les packages manquants\n  if (length(missing_packages) &gt; 0) {\n    message(\"Installation des packages manquants : \", paste(missing_packages, collapse = \", \"))\n    install.packages(missing_packages, dependencies = TRUE)\n  }\n  \n  # Charger les packages\n  lapply(packages, require, character.only = TRUE)\n  \n  \n  \n  ### GESTION DES ERREURS ----\n  \n  # Vérification du parametre table_type\n  if (table_type != \"eff\" && table_type != \"pct_ligne\" && table_type != \"pct_col\") {\n    stop(\"Erreur : table_type doit être 'eff', 'pct_ligne', ou 'pct_col' \")\n  }\n  \n  # Vérification de parametre val.manq\n  if (val.manq != \"oui\" && val.manq != \"non\") {\n    stop(\"Erreur : val.manq doit être 'oui' ou 'non'\")\n  }\n  \n  # Vérification de parametre sautdeligne\n  if (sautdeligne != \"oui\" && sautdeligne != \"non\") {\n    stop(\"Erreur : sautdeligne doit être 'oui' ou 'non'\")\n  }\n  \n  # Vérification de parametre export_XLS\n  if (export_XLS != \"oui\" && export_XLS != \"non\") {\n    stop(\"Erreur : export_XLS doit être 'oui' ou 'non'\")\n  }\n  \n  \n  ### GESTION DES PARAMETRES ----\n  \n  # Données : \n  dt &lt;- donnees\n  \n  # Variable à croiser : \n  if(is.null(var_crois) == T){\n    var_crois_OK &lt;- \"NON\"\n  } else{\n    var_crois_OK &lt;- \"OUI\"\n  }\n  \n  # Variable pondération : \n  if(is.null(ponder) == T){\n    ponder_calc &lt;- rep(1,nrow(dt))\n  } else{\n    ponder_calc &lt;- with(dt,get(ponder))\n  }\n  \n  # Valeurs manquantes\n  if(val.manq == \"oui\"){\n    NA_oupas &lt;- \"always\"\n  } else if(val.manq == \"non\"){\n    NA_oupas &lt;- \"no\"\n  }\n  \n  # Choix du type de pourcentage\n  if(table_type == \"pct_ligne\"){\n    pct_type &lt;- 1\n  } else if(table_type == \"pct_col\"){\n    pct_type &lt;- 2\n  }\n  \n  \n  ### CREATION DE LA TABLE EMPILEE ----\n  \n  # TABLE DES EFFECTIFS ----\n  if(table_type == \"eff\"){\n    \n    # Création table\n    desc_grp &lt;- data.frame()\n    desc_T &lt;- data.frame()\n    \n    for (i in c(1:length(vars))) {\n      \n      ### Création du tri à plat\n      desc_T &lt;- rbind(desc_T,\n                      as.data.frame(wtd.table(dt[,vars[i]], \n                                              weights = ponder_calc, \n                                              useNA=NA_oupas)) %&gt;% \n                        rename(Levels = Var1,\n                               ENSEMBLE = Freq) %&gt;%       \n                        mutate(Levels = as.character(Levels),\n                               Levels = if_else(is.na(Levels), \"Val.Manq.\", Levels)) %&gt;% \n                        mutate(Var = colnames(dt[vars[i]])) %&gt;%  \n                        select(Var,Levels,ENSEMBLE))\n      \n      # Ajout de ligne blanche entre les variables\n      if(sautdeligne == \"oui\"){\n        desc_T &lt;- rbind(desc_T, rep(NA, ncol(desc_T)))\n      }\n      \n      \n      ### Création tri croisé si var_crois_OK\n      if(var_crois_OK == \"OUI\"){\n        \n        \n        tab &lt;- wtd.table(dt[,vars[i]], \n                         with(dt,get(var_crois)),\n                         weights = ponder_calc, \n                         useNA=NA_oupas)\n        \n        \n        \n        desc_grp &lt;- rbind(desc_grp,\n                          as.data.frame(tab) %&gt;% \n                            pivot_wider(names_from = Var2, values_from = Freq) %&gt;% \n                            rename(Levels = Var1) %&gt;% \n                            mutate(Levels = as.character(Levels),\n                                   Levels = if_else(is.na(Levels), \"Val.Manq.\", Levels)) %&gt;% \n                            mutate(Var = colnames(dt[vars[i]]))    %&gt;%\n                            mutate(pvalue = chisq.test(\n                              xtabs(ponder_calc~ \n                                      get(colnames(dt[vars[i]]))+\n                                      get(var_crois),\n                                    data=dt))$p.value)              %&gt;% \n                            select(Var,Levels, everything()))\n        \n        # Ajout de ligne blanche entre les variables\n        if(sautdeligne == \"oui\"){\n          desc_grp &lt;- rbind(desc_grp, rep(NA, ncol(desc_grp)))\n        }\n      }\n    }\n    \n    \n    \n    ## Création base finale propre pour trier croisé\n    if(var_crois_OK == \"OUI\"){\n      \n      desc_grp &lt;- desc_grp %&gt;% \n        bind_cols(select(desc_T, \"ENSEMBLE\")) %&gt;% \n        mutate_at(colnames(.)[-c(1,2)], ~round(as.numeric(.),arrondi)) \n      \n      tabdesc = as.data.frame(t(\n        c(\"\", \"ENSEMBLE\", with(dt, round(wtd.table(get(var_crois), weights = ponder_calc, useNA=NA_oupas),2)),NA,sum(ponder_calc))))  %&gt;%\n        `colnames&lt;-`(colnames(desc_grp))\n      \n      if(sautdeligne == \"oui\"){\n        tabdesc &lt;- rbind(tabdesc, rep(NA, ncol(tabdesc)))\n      }\n      \n      tabdesc &lt;- tabdesc %&gt;% \n        rbind(desc_grp) %&gt;% \n        select(Var,Levels, ENSEMBLE, everything())\n      \n      \n      \n      ## Création base finale propre pour trier à plat\n    } else {\n      \n      desc_T &lt;- desc_T %&gt;% \n        mutate_at(colnames(.)[-c(1,2)], ~round(as.numeric(.),arrondi)) \n      \n      tabdesc = as.data.frame(t(\n        c(\"\", \"ENSEMBLE\" ,sum(ponder_calc)))) %&gt;%\n        `colnames&lt;-`(colnames(desc_T))\n      \n      if(sautdeligne == \"oui\"){\n        tabdesc &lt;- rbind(tabdesc, rep(NA, ncol(tabdesc)))\n      }\n      \n      tabdesc &lt;- tabdesc %&gt;% \n        rbind(desc_T)\n    }\n    \n  }\n  \n  if(table_type %in% c(\"pct_ligne\",\"pct_col\")){\n    \n    desc_grp &lt;- data.frame()\n    desc_T &lt;- data.frame()\n    \n    \n    for (i in c(1:length(vars))) {\n      \n      \n      ### Création du tri à plat\n      desc_T &lt;- rbind(desc_T,             \n                      as.data.frame(prop.table(\n                        wtd.table(dt[,vars[i]],  \n                                  weights = ponder_calc, \n                                  useNA=NA_oupas))*100) %&gt;% \n                        rename(Levels = Var1,\n                               ENSEMBLE = Freq) %&gt;%      \n                        mutate(Levels = as.character(Levels),\n                               Levels = if_else(is.na(Levels), \"Val.Manq.\", Levels)) %&gt;% \n                        mutate(Var = colnames(dt[vars[i]])) %&gt;% \n                        select(Var,Levels,ENSEMBLE))     \n      \n      \n      # Ajout de ligne blanche entre les variables\n      if(sautdeligne == \"oui\"){\n        desc_T &lt;- rbind(desc_T, rep(NA, ncol(desc_T)))\n      }\n      \n      \n      ### Création tri croisé si var_crois_OK\n      if(var_crois_OK == \"OUI\"){\n        \n        \n        tab &lt;- prop.table(wtd.table(dt[,vars[i]], \n                                    with(dt,get(var_crois)),\n                                    weights = ponder_calc, \n                                    useNA=NA_oupas),pct_type)*100\n        \n        \n        desc_grp &lt;- rbind(desc_grp,\n                          as.data.frame(tab) %&gt;% \n                            pivot_wider(names_from = Var2, values_from = Freq) %&gt;% \n                            rename(Levels = Var1) %&gt;% \n                            mutate(Levels = as.character(Levels),\n                                   Levels = if_else(is.na(Levels), \"Val.Manq.\", Levels)) %&gt;% \n                            mutate_all(~ifelse(is.nan(.), 0, .)) %&gt;% \n                            mutate(Var = colnames(dt[vars[i]]))    %&gt;% \n                            mutate(pvalue = chisq.test(\n                              xtabs(ponder_calc~ \n                                      get(colnames(dt[vars[i]]))+\n                                      get(var_crois),\n                                    data=dt))$p.value)    %&gt;%\n                            select(Var,Levels, everything()))\n        \n        # Ajout de ligne blanche entre les variables\n        if(sautdeligne == \"oui\"){\n          desc_grp &lt;- rbind(desc_grp, rep(NA, ncol(desc_grp)))\n        }\n      }\n    }\n    \n    \n    ## Création base finale propre pour trier croisé\n    if(var_crois_OK == \"OUI\"){\n      \n      # POUR POURCENTAGE LIGNE\n      if(pct_type == 1){\n        desc_grp &lt;- desc_grp %&gt;% \n          bind_cols(desc_T %&gt;% \n                      mutate(ENSEMBLE= if_else(ENSEMBLE == 0, ENSEMBLE, 100)) %&gt;% \n                      select( \"ENSEMBLE\")) %&gt;% \n          mutate_at(colnames(.)[-c(1,2)], ~round(as.numeric(.),arrondi)) \n        \n        tabdesc = as.data.frame(t(\n          c(\"\", \"ENSEMBLE\", round(prop.table(with(dt, wtd.table(get(var_crois), weights = ponder_calc, useNA=NA_oupas)))*100,arrondi),\n            NA,100)))  %&gt;%\n          `colnames&lt;-`(colnames(desc_grp))\n        \n        if(sautdeligne == \"oui\"){\n          tabdesc &lt;- rbind(tabdesc, rep(NA, ncol(tabdesc)))\n        }\n        \n        tabdesc &lt;- tabdesc %&gt;% \n          rbind(desc_grp) %&gt;% \n          select(Var,Levels,ENSEMBLE, everything())\n        \n        # POUR POURCENTAGE COLONNES\n      } else if(pct_type == 2){\n        \n        desc_grp &lt;- desc_grp %&gt;% \n          bind_cols(desc_T %&gt;% \n                      select( \"ENSEMBLE\")) %&gt;% \n          mutate_at(colnames(.)[-c(1,2)], ~round(as.numeric(.),arrondi)) \n        \n        \n        tabdesc = as.data.frame(t(\n          c(\"\", \"ENSEMBLE\", rep(100,length(with(dt,names(table(get(var_crois), useNA = NA_oupas))))),\n            NA,100)))  %&gt;%\n          `colnames&lt;-`(colnames(desc_grp))\n        \n        if(sautdeligne == \"oui\"){\n          tabdesc &lt;- rbind(tabdesc, rep(NA, ncol(tabdesc)))\n        }\n        \n        tabdesc &lt;- tabdesc %&gt;% \n          rbind(desc_grp) %&gt;% \n          select(Var,Levels,ENSEMBLE, everything())\n      }\n      \n      \n    } else {\n      # TRI A PLAT POURCENTAGE\n      desc_T &lt;- desc_T %&gt;% \n        mutate_at(colnames(.)[-c(1,2)], ~round(as.numeric(.),arrondi)) \n      \n      tabdesc = as.data.frame(t(\n        c(\"\", \"ENSEMBLE\" ,100))) %&gt;%\n        `colnames&lt;-`(colnames(desc_T))\n      \n      if(sautdeligne == \"oui\"){\n        tabdesc &lt;- rbind(tabdesc, rep(NA, ncol(tabdesc)))\n      }\n      \n      tabdesc &lt;- tabdesc %&gt;% \n        rbind(desc_T)\n    }\n  }\n  \n  # Enregistrer le data.frame dans l'environnement global\n  assign(\"tabdesc\", tabdesc, envir = .GlobalEnv)\n  \n  \n  # Export\n  if(export_XLS == \"oui\"){\n    # Spécifiez le nom du fichier Excel de destination\n    file_path &lt;- \"./table_empilee.xlsx\"\n    # Créez un objet workbook\n    wb &lt;- createWorkbook()\n    \n    # Ajoutez chaque data.frame en tant que feuille à l'objet workbook\n    addWorksheet(wb, table_type)\n    writeData(wb, table_type, tabdesc)\n    # Enregistrez l'objet workbook dans un fichier Excel\n    saveWorkbook(wb, file_path, overwrite = TRUE)\n  }\n  \n}"
  },
  {
    "objectID": "R/assist/posts/function_table_auto/fonction_table_auto.html#choix-des-variables",
    "href": "R/assist/posts/function_table_auto/fonction_table_auto.html#choix-des-variables",
    "title": "Fonction pour des tables automatiques",
    "section": "Choix des variables",
    "text": "Choix des variables\nOn définit les variables à croiser :\n\n\n\nChoix des variables\n\nvars      &lt;- c(\"relig\",\"trav.imp\",\"trav.satisf\",\"hard.rock\",\"lecture.bd\",\"peche.chasse\",\"cuisine\",\"bricol\",\"cinema\",\"sport\"  )\nponder    &lt;- \"poids\"\nvar_crois &lt;- \"sexe\""
  },
  {
    "objectID": "R/assist/posts/function_table_auto/fonction_table_auto.html#création-du-tableau-empilé",
    "href": "R/assist/posts/function_table_auto/fonction_table_auto.html#création-du-tableau-empilé",
    "title": "Fonction pour des tables automatiques",
    "section": "Création du tableau empilé",
    "text": "Création du tableau empilé\nEn lançant le code suivant, on crée le tableau tabdesc.\n\n\n\nActivation de la fonction\n\ntable_auto(hdv2003,              # base de données\n           vars,                 # un vecteur avec les noms des variables\n           var_crois   = \"sexe\", # si NULL : tri à plat\n           table_type  = \"eff\",  # eff, pct_lign, ou pct_col\n           ponder      = NULL,   # mettre une variable de pondération\n           val.manq    = \"non\",  # si \"oui\" avec valeurs manquantes\n           arrondi     = 4,      # nb de chiffre après la virgule\n           sautdeligne = \"oui\",  # inserer une ligne blanche entre les variables\n           export_XLS  = \"non\")  # si \"oui\" export\n\n\n\nView(tabdesc)"
  },
  {
    "objectID": "R/assist/posts/import_json/JSON.html",
    "href": "R/assist/posts/import_json/JSON.html",
    "title": "Format JSON : de la liste au dataframe",
    "section": "",
    "text": "Fonctions utilisées dans la fiche\n\n\nPackages\nFonctions\n\n\n\n\njsonlite\nfromJSON\n\n\nrjson\nfromJSON\n\n\ndata.table\nrbindlist\n\n\nBase R\nas.data.frame - knitr - class"
  },
  {
    "objectID": "R/assist/posts/import_json/JSON.html#footnotes",
    "href": "R/assist/posts/import_json/JSON.html#footnotes",
    "title": "Format JSON : de la liste au dataframe",
    "section": "Notes de bas de page",
    "text": "Notes de bas de page\n\n\nhttps://ressources.data.sncf.com/explore/dataset/menus-des-bars-tgv/table/↩︎\nPour découvrir comment utiliser des listes : https://juba.github.io/tidyverse/16-structures-donnees.html#sec-listes↩︎"
  },
  {
    "objectID": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html",
    "href": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html",
    "title": "Recoder des variables avec ifelse() - if_else - case_when()",
    "section": "",
    "text": "Fonctions utilisées dans la fiche\n\n\nPackages\nFonctions\n\n\n\n\ndplyr\nif_else - case_when - mutate\n\n\nBase R\nifelse table"
  },
  {
    "objectID": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html#procons",
    "href": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html#procons",
    "title": "Recoder des variables avec ifelse() - if_else - case_when()",
    "section": "Pro/Cons :",
    "text": "Pro/Cons :\nAvantage :\n- Pas besoin de packages supplémentaires\nInconvénient :\n\nLent\nProblème de persistence des types de modalités (surtout avec les labels et les factors)1\n\n\nCode moins lisible\nGestion des conditions multiples illisibles"
  },
  {
    "objectID": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html#exemple-1-variables-dichotomiques",
    "href": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html#exemple-1-variables-dichotomiques",
    "title": "Recoder des variables avec ifelse() - if_else - case_when()",
    "section": "Exemple 1 : Variables dichotomiques",
    "text": "Exemple 1 : Variables dichotomiques\nCréation d’une variable catégorielle taille_rec, avec deux modalités : “Grand.e”, “Petit.e”.\n\n\n\n\n\n\n# Sélection d'une seed pour obtenir le même échantillon \n# dans la création des données fictive aléatoires\nset.seed(1)\n\n# Création du jeu de données exemple\nindividus &lt;- data.frame(\n  id = 1:20,\n  # Âges aléatoires entre 18 et 65 ans\n  age = sample(18:65, 20, replace = TRUE), \n  # Tailles aléatoires entre 150 et 200 cm\n  taille = sample(150:200, 20, replace = TRUE), \n  # Sexe aléatoire (Homme ou Femme)\n  sexe = sample(c(\"Homme\", \"Femme\"), 20, replace = TRUE) \n)\n\n\n# Ajout d'une variable taill_rec pour illustrer l'utilisation de ifelse()\nindividus$taille_rec &lt;- ifelse(individus$taille &gt; 175, # Condition \n                               \"Grand.e\",              # Catégorie si VRAI \n                               \"Petit.e\")              # Catégorie si FAUX\n\n\n# Affichage de la nouvelle variable\ntable(individus$taille_rec)\n\n\nGrand.e Petit.e \n     12       8"
  },
  {
    "objectID": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html#exemple-2-variables-avec-plus-de-2-modalités",
    "href": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html#exemple-2-variables-avec-plus-de-2-modalités",
    "title": "Recoder des variables avec ifelse() - if_else - case_when()",
    "section": "Exemple 2 : Variables avec plus de 2 modalités",
    "text": "Exemple 2 : Variables avec plus de 2 modalités\nIl est possible d’empiler les fonctions ifelse() pour créer des variables avec plus de deux modalités. Pour cela on suit le schéma suivant :\n\n\n\n\n\nDans cet exemple, on divise la taille en 3 catégories :\n\nPetit.e : &lt; 165\n\nMoyen.ne : De 165 à 185\n\nGrand.e : &gt; 185\n\n\nindividus$taille_rec2 &lt;- ifelse(individus$taille &gt; 185,      # Condition 1\n                               \"Grand.e\",                    # Condi 1 Vrai \n                               ifelse(individus$taille &lt; 165,# Condition 2\n                                      \"Petit.e\",             # Condi 2 Vrai\n                                      \"Moyen.ne\"))           # Condi 1&2 Fausse\n                               \n\n\n# Affichage de la nouvelle variable\ntable(individus$taille_rec2)\n\n\n Grand.e Moyen.ne  Petit.e \n       8        9        3"
  },
  {
    "objectID": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html#exemple-3-conditions-issues-de-deux-variables-initiales",
    "href": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html#exemple-3-conditions-issues-de-deux-variables-initiales",
    "title": "Recoder des variables avec ifelse() - if_else - case_when()",
    "section": "Exemple 3 : Conditions issues de deux variables initiales",
    "text": "Exemple 3 : Conditions issues de deux variables initiales\nIl est également possible de créer des variables à partir de conditions provenant de plusieurs variables.\nDans cet exemple, nous allons créer une variable dont les catégories seront différentes selon pour les hommes et les femmes :\n\n\n\nPour les hommes :\n\nPetit.e : &lt; 180\n\nGrand.e : &gt;= 180\n\nPour les femmes :\n\nPetit.e : &lt; 170\n\nGrand.e : &gt;= 170\n\n\n\n\n\n\n\n\n\n\n\nindividus$taille_rec3 &lt;- ifelse(individus$sexe == \"Homme\" & \n                                  individus$taille &lt; 180,      # Condition 1\n                                # Condition 1 Vraie :\n                                \"Petit.e\",    \n                                # Sinon :\n                                ifelse(individus$sexe == \"Femme\" & \n                                  individus$taille &lt; 170,      # Condition 2\n                                  # Condition 2 Vraie :\n                                  \"Petit.e\",  \n                                  # Tous les autres :\n                                  \"Grand.e\"))          \n                               \n\n\n# Affichage de la nouvelle variable\ntable(individus$taille_rec3)\n\n\nGrand.e Petit.e \n     14       6"
  },
  {
    "objectID": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html#procons-1",
    "href": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html#procons-1",
    "title": "Recoder des variables avec ifelse() - if_else - case_when()",
    "section": "Pro/Cons :",
    "text": "Pro/Cons :\nAvantage :\nLe package dplyr, présent dans le tidyverse, propose sa propre version de la fonction ifelse(), qui permet d’éviter certains problèmes rencontrer avec la version de base.\nAinsi, if_else() s’utilise exactement de la même manière que ifelse, elle est plus rapide et permet de conserver le type de la variable initiale.\nInconvénient :\n\nBesoin d’installer un package\nGestion des conditions multiples toujours illisibles"
  },
  {
    "objectID": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html#exemple-4-if_else",
    "href": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html#exemple-4-if_else",
    "title": "Recoder des variables avec ifelse() - if_else - case_when()",
    "section": "Exemple 4 : if_else()",
    "text": "Exemple 4 : if_else()\n\n#install.packages(\"dplyr\")\nlibrary(dplyr)\n\nindividus$taille_rec4 &lt;- if_else(individus$sexe == \"Homme\" & \n                                  individus$taille &lt; 180,      # Condition 1\n                                # Condition 1 Vraie :\n                                \"Petit.e\",    \n                                # Sinon :\n                                if_else(individus$sexe == \"Femme\" & \n                                  individus$taille &lt; 170,      # Condition 2\n                                  # Condition 2 Vraie :\n                                  \"Petit.e\",  \n                                  # Tous les autres :\n                                  \"Grand.e\"))          \n                               \n\n\n# Affichage de la nouvelle variable\ntable(individus$taille_rec4)\n\n\nGrand.e Petit.e \n     14       6 \n\n\nOn obtient bien le même résultat"
  },
  {
    "objectID": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html#procons-2",
    "href": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html#procons-2",
    "title": "Recoder des variables avec ifelse() - if_else - case_when()",
    "section": "Pro/Cons :",
    "text": "Pro/Cons :\nLa gestion des conditions multiples pouvant être fastidieuse avec les fonctions ifelse(), le code devenant rapidemment illisible, dplyr propose la fonction case_when() qui permet de l’organiser mieux.\nSon fonctionnement se base sur des formules, il peut alors sembler plus ou moins compréhensibles selon les sensibilités de programmations."
  },
  {
    "objectID": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html#ordre-daffectation-des-valeurs",
    "href": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html#ordre-daffectation-des-valeurs",
    "title": "Recoder des variables avec ifelse() - if_else - case_when()",
    "section": "Ordre d’affectation des valeurs",
    "text": "Ordre d’affectation des valeurs\nAvec ifelse() ou avec case_when, une fois la première condition remplie, la nouvelle valeur ne peux plus être modifiée, ainsi si une condition future se superpose, elle ne sera pas prise en compte dans le recodage. On va du plus spécifique au plus général\nExemple : On crée une variable taille avec comme modalité :\n\nPetit : &lt; 170\n\nMoyen : 170 à 185\n\nGrand : &gt; 185\n\n\nindividus &lt;- individus %&gt;%\n  select(id, taille) %&gt;% \n  \n  mutate(\n    # avec ifelse\n    var1 = ifelse(taille &gt; 170, \"Moyen\", \n                  ifelse(taille &gt; 185, \"Grand\", \"Petit\")),\n    \n    # avec if_else\n    var2 = if_else(taille &gt; 170, \"Moyen\", \n                   if_else(taille &gt; 185, \"Grand\", \"Petit\")),\n    \n    # avec case_when\n    var3 = case_when(\n      taille &gt; 170 ~ \"Moyen\",\n      taille &gt; 185 ~ \"Grand\", \n      TRUE ~ \"Petit\")) \n\ntable(individus$var1)\n\n\nMoyen Petit \n   14     6 \n\ntable(individus$var2)\n\n\nMoyen Petit \n   14     6 \n\ntable(individus$var3)\n\n\nMoyen Petit \n   14     6 \n\n\nOn voit qu’il n’y a pas la catégorie “Grand”, comme la valeur a déjà été affectée à la catégorie “Moyen”. Il faudrait alors :\n\nindividus &lt;- individus %&gt;%\n  mutate(var5 = case_when(\n    taille &gt; 185 ~ \"Grand\", \n    taille &gt; 170 ~ \"Moyen\",\n    TRUE ~ \"Petit\")) \n\ntable(individus$var5)\n\n\nGrand Moyen Petit \n    8     6     6"
  },
  {
    "objectID": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html#a-propos-des-valeurs-manquantes",
    "href": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html#a-propos-des-valeurs-manquantes",
    "title": "Recoder des variables avec ifelse() - if_else - case_when()",
    "section": "A propos des valeurs manquantes",
    "text": "A propos des valeurs manquantes\nLes fonctions ifelse() n’ont pas le même comportement pour le traitement des valeurs manquantes que la fonction case_when.\nDans le cas des fonctions ifelse, si l’une des variables de conditions est un NA, le résultat sera également une valeur manquante dans la variable crée.\nDans le cas de la fonction case_when, l’individu avec une valeur manquante aura comme nouvelle valeur la catégorie défini dans la partie “SINON”.2\nExemple :\nOn crée un data frame avec des NA :\n\nlibrary(dplyr)\ndf &lt;- data.frame(a = c(1:3, NA, 4,NA,6:7), b = c(NA, letters[1:7]))\ndf\n\n   a    b\n1  1 &lt;NA&gt;\n2  2    a\n3  3    b\n4 NA    c\n5  4    d\n6 NA    e\n7  6    f\n8  7    g\n\n\nOn fait un recodage avec ifelse()\n\ndf %&gt;%\n  mutate(res = if_else(a &gt; 3, \"Yes\", \n                   if_else(b == \"c\", \"No\", \n                           if_else(a &gt; 5, \"Maybe\", \"Done\"))))\n\n   a    b  res\n1  1 &lt;NA&gt; &lt;NA&gt;\n2  2    a Done\n3  3    b Done\n4 NA    c &lt;NA&gt;\n5  4    d  Yes\n6 NA    e &lt;NA&gt;\n7  6    f  Yes\n8  7    g  Yes\n\n\nLes NA restent des NAs, alors qu’avec case_when :\n\ndf %&gt;%\n   mutate(res = case_when(a &gt; 3 ~ \"Yes\", \n                          b == \"c\"~\"No\", \n                          a &gt; 5 ~ \"Maybe\", \n                          TRUE ~ \"Done\"))\n\n   a    b  res\n1  1 &lt;NA&gt; Done\n2  2    a Done\n3  3    b Done\n4 NA    c   No\n5  4    d  Yes\n6 NA    e Done\n7  6    f  Yes\n8  7    g  Yes\n\n\nOn a pas de NA, ils ont été recodé avec la catégorie SINON.\nIl faut donc créer une condition avec is.na(variable)\n\ndf %&gt;%\n   mutate(res = case_when(a &gt; 3 ~ \"Yes\", \n                          b == \"c\"~\"No\", \n                          a &gt; 5 ~ \"Maybe\", \n                          is.na(a) | is.na(b) ~ NA,\n                          TRUE ~ \"Done\"))\n\n   a    b  res\n1  1 &lt;NA&gt; &lt;NA&gt;\n2  2    a Done\n3  3    b Done\n4 NA    c   No\n5  4    d  Yes\n6 NA    e &lt;NA&gt;\n7  6    f  Yes\n8  7    g  Yes"
  },
  {
    "objectID": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html#footnotes",
    "href": "R/assist/posts/ifelse_casewhen/ifelse_casewhen.html#footnotes",
    "title": "Recoder des variables avec ifelse() - if_else - case_when()",
    "section": "Notes de bas de page",
    "text": "Notes de bas de page\n\n\nhttps://community.rstudio.com/t/case-when-why-not/2685/3↩︎\nhttps://stackoverflow.com/questions/57807976/how-to-use-case-when-rather-then-if-else-error-in-my-code↩︎"
  }
]